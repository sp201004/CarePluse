{"version":3,"file":"responseEnd.js","sources":["../../../../src/common/utils/responseEnd.ts"],"sourcesContent":["import type { ServerResponse } from 'http';\nimport type { Span } from '@sentry/core';\nimport { fill, flush, logger, setHttpStatus } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { ResponseEndMethod, WrappedResponseEndMethod } from '../types';\n\n/**\n * Wrap `res.end()` so that it ends the span and flushes events before letting the request finish.\n *\n * Note: This wraps a sync method with an async method. While in general that's not a great idea in terms of keeping\n * things in the right order, in this case it's safe, because the native `.end()` actually *is* (effectively) async, and\n * its run actually *is* (literally) awaited, just manually so (which reflects the fact that the core of the\n * request/response code in Node by far predates the introduction of `async`/`await`). When `.end()` is done, it emits\n * the `prefinish` event, and only once that fires does request processing continue. See\n * https://github.com/nodejs/node/commit/7c9b607048f13741173d397795bac37707405ba7.\n *\n * Also note: `res.end()` isn't called until *after* all response data and headers have been sent, so blocking inside of\n * `end` doesn't delay data getting to the end user. See\n * https://nodejs.org/api/http.html#responseenddata-encoding-callback.\n *\n * @param span The span tracking the request\n * @param res: The request's corresponding response\n */\nexport function autoEndSpanOnResponseEnd(span: Span, res: ServerResponse): void {\n  const wrapEndMethod = (origEnd: ResponseEndMethod): WrappedResponseEndMethod => {\n    return function sentryWrappedEnd(this: ServerResponse, ...args: unknown[]) {\n      finishSpan(span, this);\n      return origEnd.call(this, ...args);\n    };\n  };\n\n  // Prevent double-wrapping\n  // res.end may be undefined during build when using `next export` to statically export a Next.js app\n  if (res.end && !(res.end as WrappedResponseEndMethod).__sentry_original__) {\n    fill(res, 'end', wrapEndMethod);\n  }\n}\n\n/** Finish the given response's span and set HTTP status data */\nexport function finishSpan(span: Span, res: ServerResponse): void {\n  setHttpStatus(span, res.statusCode);\n  span.end();\n}\n\n/**\n * Flushes pending Sentry events with a 2 second timeout and in a way that cannot create unhandled promise rejections.\n */\nexport async function flushSafelyWithTimeout(): Promise<void> {\n  try {\n    DEBUG_BUILD && logger.log('Flushing events...');\n    await flush(2000);\n    DEBUG_BUILD && logger.log('Done flushing events');\n  } catch (e) {\n    DEBUG_BUILD && logger.log('Error while flushing events:\\n', e);\n  }\n}\n"],"names":["DEBUG_BUILD","logger","flush"],"mappings":";;;;;AA4CA;AACA;AACA;AACO,eAAe,sBAAsB,GAAkB;AAC9D,EAAE,IAAI;AACN,IAAIA,0BAAeC,WAAM,CAAC,GAAG,CAAC,oBAAoB,CAAC;AACnD,IAAI,MAAMC,UAAK,CAAC,IAAI,CAAC;AACrB,IAAIF,0BAAeC,WAAM,CAAC,GAAG,CAAC,sBAAsB,CAAC;AACrD,GAAI,CAAA,OAAO,CAAC,EAAE;AACd,IAAID,sBAAA,IAAeC,WAAM,CAAC,GAAG,CAAC,gCAAgC,EAAE,CAAC,CAAC;AAClE;AACA;;;;"}