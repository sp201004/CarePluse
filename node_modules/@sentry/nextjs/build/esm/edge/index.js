import { _optionalChain } from '@sentry/core';
import { registerSpanErrorInstrumentation, applySdkMetadata, GLOBAL_OBJ, spanToJSON, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, stripUrlQueryAndFragment, getRootSpan, vercelWaitUntil } from '@sentry/core';
import { getDefaultIntegrations, init as init$1 } from '@sentry/vercel-edge';
export * from '@sentry/vercel-edge';
import { isBuild } from '../common/utils/isBuild.js';
import { flushSafelyWithTimeout } from '../common/utils/responseEnd.js';
import { distDirRewriteFramesIntegration } from './distDirRewriteFramesIntegration.js';
export { wrapGetStaticPropsWithSentry } from '../common/pages-router-instrumentation/wrapGetStaticPropsWithSentry.js';
export { wrapGetInitialPropsWithSentry } from '../common/pages-router-instrumentation/wrapGetInitialPropsWithSentry.js';
export { wrapAppGetInitialPropsWithSentry } from '../common/pages-router-instrumentation/wrapAppGetInitialPropsWithSentry.js';
export { wrapDocumentGetInitialPropsWithSentry } from '../common/pages-router-instrumentation/wrapDocumentGetInitialPropsWithSentry.js';
export { wrapErrorGetInitialPropsWithSentry } from '../common/pages-router-instrumentation/wrapErrorGetInitialPropsWithSentry.js';
export { wrapGetServerSidePropsWithSentry } from '../common/pages-router-instrumentation/wrapGetServerSidePropsWithSentry.js';
export { wrapServerComponentWithSentry } from '../common/wrapServerComponentWithSentry.js';
export { wrapRouteHandlerWithSentry } from '../common/wrapRouteHandlerWithSentry.js';
export { wrapApiHandlerWithSentryVercelCrons } from '../common/pages-router-instrumentation/wrapApiHandlerWithSentryVercelCrons.js';
export { wrapMiddlewareWithSentry } from '../common/wrapMiddlewareWithSentry.js';
export { wrapPageComponentWithSentry } from '../common/pages-router-instrumentation/wrapPageComponentWithSentry.js';
export { wrapGenerationFunctionWithSentry } from '../common/wrapGenerationFunctionWithSentry.js';
export { withServerActionInstrumentation } from '../common/withServerActionInstrumentation.js';
export { captureRequestError, experimental_captureRequestError } from '../common/captureRequestError.js';
export { captureUnderscoreErrorException } from '../common/pages-router-instrumentation/_error.js';
export { wrapApiHandlerWithSentry } from './wrapApiHandlerWithSentry.js';

const globalWithInjectedValues = GLOBAL_OBJ

;

/** Inits the Sentry NextJS SDK on the Edge Runtime. */
function init(options = {}) {
  registerSpanErrorInstrumentation();

  if (isBuild()) {
    return;
  }

  const customDefaultIntegrations = getDefaultIntegrations(options);

  // This value is injected at build time, based on the output directory specified in the build config. Though a default
  // is set there, we set it here as well, just in case something has gone wrong with the injection.
  const distDirName = process.env._sentryRewriteFramesDistDir || globalWithInjectedValues._sentryRewriteFramesDistDir;

  if (distDirName) {
    customDefaultIntegrations.push(distDirRewriteFramesIntegration({ distDirName }));
  }

  const opts = {
    defaultIntegrations: customDefaultIntegrations,
    ...options,
  };

  applySdkMetadata(opts, 'nextjs');

  const client = init$1(opts);

  _optionalChain([client, 'optionalAccess', _ => _.on, 'call', _2 => _2('spanStart', span => {
    const spanAttributes = spanToJSON(span).data;

    // Mark all spans generated by Next.js as 'auto'
    if (_optionalChain([spanAttributes, 'optionalAccess', _3 => _3['next.span_type']]) !== undefined) {
      span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, 'auto');
    }

    // Make sure middleware spans get the right op
    if (_optionalChain([spanAttributes, 'optionalAccess', _4 => _4['next.span_type']]) === 'Middleware.execute') {
      span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'http.server.middleware');
      span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, 'url');
    }
  })]);

  // Use the preprocessEvent hook instead of an event processor, so that the users event processors receive the most
  // up-to-date value, but also so that the logic that detects changes to the transaction names to set the source to
  // "custom", doesn't trigger.
  _optionalChain([client, 'optionalAccess', _5 => _5.on, 'call', _6 => _6('preprocessEvent', event => {
    // The otel auto inference will clobber the transaction name because the span has an http.target
    if (
      event.type === 'transaction' &&
      _optionalChain([event, 'access', _7 => _7.contexts, 'optionalAccess', _8 => _8.trace, 'optionalAccess', _9 => _9.data, 'optionalAccess', _10 => _10['next.span_type']]) === 'Middleware.execute' &&
      _optionalChain([event, 'access', _11 => _11.contexts, 'optionalAccess', _12 => _12.trace, 'optionalAccess', _13 => _13.data, 'optionalAccess', _14 => _14['next.span_name']])
    ) {
      if (event.transaction) {
        event.transaction = stripUrlQueryAndFragment(event.contexts.trace.data['next.span_name']);
      }
    }
  })]);

  _optionalChain([client, 'optionalAccess', _15 => _15.on, 'call', _16 => _16('spanEnd', span => {
    if (span === getRootSpan(span)) {
      vercelWaitUntil(flushSafelyWithTimeout());
    }
  })]);
}

/**
 * Just a passthrough in case this is imported from the client.
 */
function withSentryConfig(exportedUserNextConfig) {
  return exportedUserNextConfig;
}

export { init, withSentryConfig };
//# sourceMappingURL=index.js.map
